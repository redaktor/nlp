import _ = require("../../../nlp/fns");

/**
 * data module, autogenerated by grunt. <br>
 * change and contribute to dictionaryRules <br>
 *  <br>
 * regex rules and suffixes for verb conjugation <br>
 * used in combination with the generic "fallback" method <br>
 *  <br>
 * @readonly
 * @module data/en/rules/verb
 */


  var zip:any = { conjugate: 
   { infinitive: 
      [ [ '(eed)$', 0, '$1s', '$1ing', '$1ed', '$1er' ],
        [ '(e)(ep)$', 0, '$1$2s', '$1$2ing', '$1pt', '$1$2er' ],
        [ '(a[tg]|i[zn]|ur|nc|gl|is)e$', 0, '$1es', '$1ing', '$1ed', 0 ],
        [ '([i|f|rr])y$', 0, '$1ies', '$1ying', '$1ied', 0 ],
        [ '([td]er)$', 0, '$1s', '$1ing', '$1ed', 0 ],
        [ '([bd]l)e$', 0, '$1es', '$1ing', '$1ed', 0 ],
        [ '(ish|tch|ess)$', 0, '$1es', '$1ing', '$1ed', 0 ],
        [ '(ion|end|e[nc]t)$', 0, '$1s', '$1ing', '$1ed', 0 ],
        [ '(om)e$', 0, '$1es', '$1ing', 'ame', 0 ],
        [ '([aeiu])([pt])$', 0, '$1$2s', '$1$2$2ing', '$1$2', 0 ],
        [ '(er)$', 0, '$1s', '$1ing', '$1ed', 0 ],
        [ '(en)$', 0, '$1s', '$1ing', '$1ed', 0 ] ],
     present: 
      [ [ '(ies)$', 'y', 0, 'ying', 'ied', 0 ],
        [ '(tch|sh)es$', '$1', 0, '$1ing', '$1ed', 0 ],
        [ '(ss)es$', '$1', 0, '$1ing', '$1ed', 0 ],
        [ '([tzlshicgrvdnkmu])es$', '$1e', 0, '$1ing', '$1ed', 0 ],
        [ '(n[dtk]|c[kt]|[eo]n|i[nl]|er|a[ytrl])s$',
          '$1',
          0,
          '$1ing',
          '$1ed',
          0 ],
        [ '(ow)s$', '$1', 0, '$1ing', 'ew', 0 ],
        [ '(op)s$', '$1', 0, '$1ping', '$1ped', 0 ],
        [ '([eirs])ts$', '$1t', 0, '$1tting', '$1tted', 0 ],
        [ '(ll)s$', '$1', 0, '$1ing', '$1ed', 0 ],
        [ '(el)s$', '$1', 0, '$1ling', '$1led', 0 ],
        [ '(ip)es$', '$1e', 0, '$1ing', '$1ed', 0 ],
        [ 'ss$', 'ss', 0, 'ssing', 'ssed', 0 ],
        [ 's$', '', 0, 'ing', 'ed', 0 ] ],
     gerund: 
      [ [ 'pping$', 'p', 'ps', 0, 'pped', 0 ],
        [ 'lling$', 'll', 'lls', 0, 'lled', 0 ],
        [ 'tting$', 't', 'ts', 0, 't', 0 ],
        [ 'ssing$', 'ss', 'sses', 0, 'ssed', 0 ],
        [ 'gging$', 'g', 'gs', 0, 'gged', 0 ],
        [ '([^aeiou])ying$', '$1y', '$1ies', 0, '$1ied', '$1ier' ],
        [ '(i.)ing$', '$1e', '$1es', 0, '$1ed', 0 ],
        [ '(u[rtcb]|[bdtpkg]l|n[cg]|a[gdkvtc]|[ua]s|[dr]g|yz|o[rlsp]|cre)ing$',
          '$1e',
          '$1es',
          0,
          '$1ed',
          0 ],
        [ '(ch|sh)ing$', '$1', '$1es', 0, '$1ed', 0 ],
        [ '(..)ing$', '$1', '$1s', 0, '$1ed', 0 ] ],
     past: 
      [ [ '(ued)$', 0, 'ues', 'uing', 'ued', 'uer' ],
        [ '(e|i)lled$', 0, '$1lls', '$1lling', '$1lled', '$1ller' ],
        [ '(sh|ch)ed$', '$1', '$1es', '$1ing', 0, '$1er' ],
        [ '(tl|gl)ed$', '$1e', '$1es', '$1ing', 0, '$1er' ],
        [ '(ss)ed$', '$1', '$1es', '$1ing', 0, '$1er' ],
        [ 'pped$', 'p', 'ps', 'pping', 0, 'pper' ],
        [ 'tted$', 't', 'ts', 'tting', 0, 'tter' ],
        [ 'gged$', 'g', 'gs', 'gging', 0, 'gger' ],
        [ '(h|ion|n[dt]|ai.|[cs]t|pp|all|ss|tt|int|ail|ld|en|oo.|er|k|pp|w|ou.|rt|ght|rm)ed$',
          '$1',
          '$1s',
          '$1ing',
          0,
          '$1er' ],
        [ '(..[^aeiou])ed$', '$1e', '$1es', '$1ing', 0, '$1er' ],
        [ 'ied$', 'y', 'ies', 'ying', 0, 'ier' ],
        [ '(.o)ed$', '$1o', '$1os', '$1oing', 0, '$1oer' ],
        [ '(.i)ed$', '$1', '$1s', '$1ing', 0, '$1er' ],
        [ '([rl])ew$', '$1ow', '$1ows', '$1owing', 0, 0 ],
        [ '([pl])t$', '$1t', '$1ts', '$1ting', 0, 0 ] ] },
  detect: 
   [ [ /^will\b/, 'future' ],
     [ /([aeiou][^aeiouwyrlm])ing$/, 'gerund' ],
     [ /n't$/, 'negative' ] ],
  unPrefix: /^(over|under|re|anti|full)\-?/i,
  fallback: function (w, o) {
			if (w.length > 4) {
				o.infinitive = w.replace(/ed$/, '');
			} else {
				o.infinitive = w.replace(/d$/, '');
			}
			if (w.match(/[^aeiou]$/)) {
				o.gerund = [w, 'ing'].join('');
				o.past = [w, 'ed'].join('');
				if (w.match(/ss$/)) {
					o.present = [w, 'es'].join(''); //'passes'
				} else {
					o.present = [w, 's'].join('');
				}
			} else {
				o.gerund = w.replace(/[aeiou]$/, 'ing');
				o.past = w.replace(/[aeiou]$/, 'ed');
				o.present = w.replace(/[aeiou]$/, 'es');
			}
			return o;
		},
  fulfill: function (o) {
			return {
				gerund: [o.infinitive, 'ing'],
				present: [o.infinitive, 's'],
				past: [o.infinitive, 'ed'],
				future: ['will ', o.infinitive],
				perfect: ['have ', o.past],
				pluperfect: ['had ', o.past],
				futurePerfect: ['will have ', o.past]
			};
		},
  doer: 
   [ [ /e$/i, 'er' ],
     [ /([aeiou])([mlgp])$/i, '$1$2$2er' ],
     [ /([rlf])y$/i, '$1ier' ],
     [ /^(.?.[aeiou])t$/i, '$1tter' ] ],
  tenseReplace: 
   { pluperfect: { matches: /^had [a-z]/i, replaces: /^had /i, replacer: '' },
     perfect: { matches: /^have [a-z]/i, replaces: /^have /i, replacer: '' },
     futurePerfect: 
      { matches: /^will have [a-z]/i,
        replaces: /^will have /i,
        replacer: '' },
     future: { replaces: /^will /i, replacer: '' } },
  suffixes: 
   { gerund: [ 'ing' ],
     infinitive: 
      [ 'ate',
        'ize',
        'tion',
        'rify',
        'ress',
        'ify',
        'age',
        'nce',
        'ect',
        'ise',
        'ine',
        'ish',
        'ace',
        'ash',
        'ure',
        'tch',
        'end',
        'ack',
        'and',
        'ute',
        'ade',
        'ock',
        'ite',
        'ase',
        'ose',
        'use',
        'ive',
        'int',
        'nge',
        'lay',
        'est',
        'ain',
        'ant',
        'eed',
        'er',
        'le' ],
     past: [ 'ed', 'lt', 'nt', 'pt', 'ew', 'ld' ],
     present: 
      [ 'rks',
        'cks',
        'nks',
        'ngs',
        'mps',
        'tes',
        'zes',
        'ers',
        'les',
        'acks',
        'ends',
        'ands',
        'ocks',
        'lays',
        'eads',
        'lls',
        'els',
        'ils',
        'ows',
        'nds',
        'ays',
        'ams',
        'ars',
        'ops',
        'ffs',
        'als',
        'urs',
        'lds',
        'ews',
        'ips',
        'es',
        'ts',
        'ns',
        's' ] } }
export = (function () {

				zip.detect = _.toObjDeep(zip.detect, ['matches', 'returns']);
				zip.detect = _.tokenFn(zip, 'detect', 1);
				zip.doer = _.toObjDeep(zip.doer, ['matches', 'replacer']);
				zip.doerReplace = _.tokenFn(zip, 'doer');
				zip.tenseReplace = _.tokenFn(zip, 'tenseReplace');
				zip.suffixes = _.toObjValues(zip.suffixes);
				for (var cat in zip.conjugate) {
					zip.conjugate[cat] = zip.conjugate[cat].map(function(a){
						return {
							reg: new RegExp(a[0],'i'),
							repl: {
								infinitive:a[1],
								present:a[2],
								gerund:a[3],
								past:a[4],
								doer:a[5]
							}
						};
					});
				}
				return zip;
			})();