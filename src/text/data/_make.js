
/* This tool will build the lexica from dictionary !
// It will automatically detect the languages and build the according folders.

// This MUST be used with node.js
// we recommend you to simply run it with

// grunt

// OR use it as a CLI-Tool:
//  LIST possible languages:
//    node _build -ls
//  GENERATE all languages :
//    node _build -l
//  GENERATE one language :
//    node _build -l en
//  GENERATE some languages :
//    node _build -l en,de

// OR as module:
//  all languages :
//    require('./_build')();
//  one language :
//    require('./_build')('en');
//  some languages :
//    require('./_build')(['en','de']);

// -->
// RETURNS module files, uncompressed and compressed
// written in folders named after the language, e.g.
// ./en/...
*/

/* TODO
// all counterpart obj. (adverb/adjective) could become TS enums for optimal performance and 2 way binding !
// jsDOC for lexicon (from original)
// brainstorm:
// DOC the {{}} stuff to real JSdoc for methods with return types etc. ...
// DOC the dictionaries to real JSdoc and use it to document data's methods "...
// schema - maximized, readable module version and maybe as JSON Schema (could be reused for validation) ...
// verbs conjugation for lexicon - the multiple forms like futures (not tagged because were not used yet)
*/
var fs = require('fs');
var path = require('path');
var util = require('util');
// target, changes to absolute path if used as module :
var PATH = '../i18n/nls/';
function absPath(fName){ return path.join(path.dirname(fName),PATH); }
function setMyPath(site){
	// automatically set data path from the callsite (see module.exports)
	// "can be used anywhere, also in grunt ..."
	var fnName = site.getFunctionName() || '?';
	var fName = site.getFileName();
	var lNr = site.getLineNumber();
	// log only us and grunt
	if (fnName != '?' && fnName.indexOf('Module.') != 0) {
		console.log('  \033[36m%s\033[90m in %s:%d\033[0m', fnName, fName, lNr);
	}
	// determine our PATH
	if (fnName === 'exports.main') {
		PATH = absPath(fName);
		console.log( '\033[90m  [\033[0m\033[32mfound the data path:\033[90m %s]\033[0m', PATH );
	}
}
// fns used only for _maker (functions and regexes in obj)
var __ = require('./_maker/_');
// i18n Corpus Data:
var dict = require('./dictionary');
var possibleLanguages = {}; // changes to all languages in the dictionary

// remember during build
var data = {}, zip;
// generate the DATA MODULES from dictionaries
// /_makers order
var maker = [
	// sort out multiple words
	'multiples',
	// NOUN
	'nounsInflect', 'nouns',
	// VERB
	'verbsSpecial', 'verbsConjugate', 'verbs',
	// ADJECTIVE
	'adjectivesDecline', 'adjectivesDemonym', 'adjectives',
	// ADVERB
	'adverbsDecline',
	// OTHER :
	// numbers, dates, honorifics, abbreviations, normalisations, suffixes
	'numbers',
	'dates',
	'honorifics',
	'abbreviations',
	'pos',
	'negate',
	'firstnames',
	'phrasalVerbs',
	'normalisations',
	'wordnet',
	'rulesPos',
	'rulesSentence',
	'rulesVerb',
	'rulesNoun',
	'rulesAdjective',
	'rulesAdverb',
	'rulesNumber',
	'rulesUnits',
	'rulesDate'
];
var plObj = {};
var ignores = ['uid', 'ref', 'title', 'description', 'tag', 'meta', 'int'];
for (var cat in dict) {
	if (dict[cat].hasOwnProperty('words')) {
		dict[cat].words.forEach(function(o) {
			for (var k in o) {
				if (ignores.indexOf(k) < 0) {
					if (!plObj.hasOwnProperty(k)) plObj[k] = 0;
					plObj[k]++;
				}
			}
		});
	}
}
possibleLanguages = Object.keys(plObj);
// some string constants
var C = {
	_: '\n',
	zip: 'declare var zip:any;\nzip = ',
	exp: '\nexport = zip;\n',
	mod1: '\nexport = (',
	mod2: ')();\n',
	doc: ' * ',
	doc1: '/**\n',
	doc2: ' */\n',
	docm: ' * @module '
};
var _regex = /\b(_)[\[.]["']*[a-zA-Z_]+["'\]]*/g;
var replO = {};
function format(o, wasKey) {
	var str = '';
	for (var k in o) {
		var res = o[k];
		if (typeof res === 'function' && !(res instanceof RegExp)) {
			var rKey = ['REPLACE+_+', wasKey||'_', k].join('');
			replO[rKey] = res;
			o[k] = rKey;
		} else if (typeof res === 'object' && !(res instanceof RegExp)) {
			format(res, k);
		}
	}
	str = util.inspect(o, { depth: null });
	for (var rk in replO) {
		str = str.replace(["'",rk,"'"].join(''), replO[rk].toString(-1));
	}
	return str;
}
function getMeta(g, lang, folder){
	var nl = [' <br>', C._, C.doc].join('');
	var meta = [C.doc, 'data module, autogenerated by grunt.', nl];
	var dicts = ['dictionaryRules', 'dictionaryNames', 'dictionary'];
	var cm = (g.folder === 'rules') ? dicts[0] : ((g.id === 'firstnames') ? dicts[1]:dicts[2]);
	meta.push('change and contribute to ', cm, nl, nl);
	var modu = [C.docm, 'data/', lang, '/', folder, g.id, C._];
	if (typeof g.description === 'string' && g.description != '') {
		meta = meta.concat([g.description.replace(/\n/gm, nl), nl]);
	}
	meta.push(nl, '@readonly', C._);
	return [C.doc1, meta.join(''), modu.join(''), C.doc2];
}
function makeLanguageModule(key,i){
	var g = require('./_maker/'+key);
	if (!g.hasOwnProperty('zip')) { return; }
	// folder
	var fUp = (g.hasOwnProperty('folder')) ? '../' : '';
	var _require = ['import _ = require("../../', fUp, 'nlp/_");\n'].join('');
	var folder = '';
	if (fUp === '../') {
		folder = g.folder+'/';
		// make subfolder in {{lang}}
		try { fs.mkdirSync(path.join(PATH, lang, folder)); } catch (e) {};
	}
	var jsDocs = getMeta(g, lang, folder);
	var strings = {
		main: [jsDocs.join(''), g.prefix||'', C._],
		zip: [g.prefix||'', C._]
	};

	var m = require('./_maker')(key,lang,1);
	strings.main.push([C.zip,format(m),C.exp].join(''));
	data[key] = m;
	m = require('./_maker/'+key).zip(lang,1);
	strings.zip.push([C.zip,format(m)].join(''));
	if (g.hasOwnProperty('unzip')) {
		var unzips = [];
		var unzStr = g.unzip.toString().replace(/\/\*::((?:\w|[[]])+)::\*\//g,':$1');
		strings.zip = strings.zip.concat([C._, C.mod1, unzStr, C.mod2]);
	} else {
		strings.zip = strings.zip.concat([C.exp]);
	}

	// WRITE the generated ...
	mainStr = strings.main.join('').trim();
	zipStr = (g.makeUnzip) ? mainStr : strings.zip.join('').trim();
	// check if any needs the _ helper module
	if (mainStr.match(_regex)) {
		mainStr = [_require, C._, mainStr].join('');
	}
	if (zipStr.match(_regex)) {
		zipStr = [_require, C._, zipStr].join('');
	}
	// TODO - run through beautifier
	fs.writeFileSync( path.join(PATH, lang, folder, g.id.concat('.ts')), mainStr);
	fs.writeFileSync( path.join(PATH, lang, folder, g.id.concat('.min.ts')), zipStr);
	var colors = ['',''];
	meta = (g.folder) ? [folder, g.id].join('') : g.id;
	var nr = i+1;
	var nrStr = (nr<10) ? '0'+nr : nr.toString();
	console.log( 'wrote module file for language', '"'+lang+'" :', [colors[0],nrStr,' of ',maker.length,colors[1]].join(''), ['(', meta, ')'].join('') );
	if (nr === maker.length) {
		require('./_maker/lexicon')(PATH, maker, data, lang);
		require('./_maker/lexicon')(PATH, maker, data, lang, 1);
	}
}
// API
// MODULE ::
exports.main = function (langOrLangs) {
	console.log( '\033[4minfo\033[0m' );
	var stack = function () {
		var orig = Error.prepareStackTrace;
		Error.prepareStackTrace = function(_, stack){ return stack; };
		var err = new Error;
		Error.captureStackTrace(err, arguments.callee);
		var stack = err.stack;
		Error.prepareStackTrace = orig;
		return stack;
	}
	stack().forEach(setMyPath);
	console.log( ' ' );
	console.log( ':) \033[4mWriting data files for natural language processing\033[0m' );
	console.log( ' ' );
	if (!langOrLangs) {
		// all languages in the dictionary ...
		langOrLangs = possibleLanguages;
	} else if (!(langOrLangs instanceof Array)) {
		langOrLangs = [langOrLangs];
	}
	console.log(langOrLangs)
	langOrLangs.forEach(function(_lang){
		lang = __.setLang(_lang);
		try { fs.mkdirSync(path.join(PATH, lang)); } catch (e) {};
		try { fs.mkdirSync(path.join(PATH, lang, 'lexicon')); } catch (e) {};
		maker.forEach(makeLanguageModule);
	});
}
module.exports = exports.main;
// CLI ::
var langOrLangs;
var CLIpos = process.argv.indexOf("-ls");
// TODO minor - language metrics are absolute, e.g. en: 3200 (words)
// once we have multiple languages, convert in 'translated' percents: {en: 100, de: 80}
var wUnit = 'words';
var pl = {};
for (var k in plObj) { pl[k] = plObj[k]+' '+wUnit; }
if(CLIpos > -1){
	console.log( pl );
} else {
	CLIpos = process.argv.indexOf("-l");
	if(CLIpos > -1){
		if (!(process.argv[CLIpos + 1])) {
			console.log( 'Generating', pl );
			exports.main(possibleLanguages);
		} else {
			langOrLangs = process.argv[CLIpos + 1].replace(/ /g, '');
			if (langOrLangs.indexOf(',') > -1) {
				exports.main(langOrLangs.split(','));
			} else {
				exports.main(langOrLangs)
			}
		}
	}
}
